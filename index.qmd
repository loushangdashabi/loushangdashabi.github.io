---
title: "在R中使用 Python 模块 Mesa 来创建 ABM 模型"
author:
  - "楼上"
  - "Mesa 开发团队 (提供demo)"
date: "`r format(Sys.time(), '%Y-%m-%d')`"

description: >
  使用 R 调用 Mesa 库构建 ABM，模型 demo 完全来源于 Mesa 官方教程，
  代码经过轻度改编，持续更新中。

project:
  type: website
  output-dir: docs

website:
  title: "在R中使用 Python 模块 Mesa 来创建 ABM 模型"

format:
  html:
    theme:
      light: flatly
      dark: darkly
    respect-user-color-scheme: true

    toc: true
    toc-location: left
    toc-depth: 5
    page-layout: full

    fig-align: center
    highlight-style: github
    code-copy: true
    number-sections: true

    grid:
      sidebar-width: 350px

filters:
  - language-marker
---

# 准备步骤

## 安装 python 环境并安装 mesa

(只需要运行一次)

```{r,eval=F}
#| display-language: true
library(reticulate)
install_miniconda()
conda_create(envname = "mesa-abm", python_version = "3.13.5")
py_install(c("mesa[all]","seaborn"), envname = "mesa-abm", pip = TRUE)
```

## 启动 python 环境

(每次都需要运行)

```{r}
#| display-language: true
library(reticulate)
use_condaenv("mesa-abm", required = TRUE)
```

## 导入需要的 python 模块

```{python}
#| display-language: true
import mesa
import seaborn as sns
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

# 模型示例: Boltzmann 财富模型

在这个模型中，每个 Agent 会初始化 1 个单位的货币，并在每个 step 中随机给另一个 Agent 1 个单位的货币。

## 创建 Agent 类

Mesa 会自动为每个创建的 Agent 分配一个整数作为 unique_id。

下面这段代码创建了一个新类 (class) MoneyAgent，继承了 mesa.Agent 类的属性。

mesa.Agent 是 Mesa 模块中定义的一个基类，所有的 Agent 都应该继承这个类。

```{python}
#| display-language: true
class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""
    
    #初始化，每次使用 MoneyAgent 创建新对象时都会使用如下初始化
    def __init__(self, model): #self代表当前对象，model 代表模型对象
      
        # 将父类中的参数 model (mesa.Agent) 传入，让Agent知道自己所属的模型
        super().__init__(model)

        # 创建 Agent 的变量 wealth 并设置初始值
        self.wealth = 1
```

## 创建模型类

创建一个模型类，继承自 mesa.Model，负责创建、保存和管理所有 Agent。

```{python}
#| display-language: true
class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n, seed=None): # n是创建的 Agent 数量，seed 是随机种子
        super().__init__(seed=seed)
        #在self (即当前模型) 中创建一个属性 num_agents，保存 Agent 的数量
        self.num_agents = n 
        # 调用类方法 create_agents，创建 n 个 Agent
        MoneyAgent.create_agents(model=self, n=n)
```

## 让 Agents "do"

通过 do 让 ABM 运行起来，mesa 中的 do 可以按不同的顺序激活 Agent。

在每一个 step 中，(通常) 每一个 Agent 都会被激活并采取自己的行动，在内部发生变化和/或与彼此或者环境交互。

此处使用 agent.shuffle_do() 来实现随机重新排序激活顺序。

```{python}
#| display-language: true
class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""

    def __init__(self, model):
        super().__init__(model)
        self.wealth = 1
        #以上代码同上
        
        # 定义一个方法 say_hi，每个 step 中都会被调用
    def say_hi(self):
        # 为了演示，输出了每个 Agent 的 unique_id
        print(f"Hi, I am an agent, you can call me {str(self.unique_id)}.")


class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n, seed=None):
        super().__init__(seed=seed)
        self.num_agents = n

        MoneyAgent.create_agents(model=self, n=n)
        #以上代码同上

    # 定义模型的 step 方法
    def step(self):
        """Advance the model by one step."""
        
        #随机重新排序 Agent 的激活顺序，并调用每个 Agent 的 say_hi 方法
        self.agents.shuffle_do("say_hi")
```

### 运行模型

创建一个模型对象 (object) 并运行它的 step 方法。

```{python}
#| display-language: true

#创建模型对象 starter_model，使用 MoneyModel 类
#此处的 10 对应 MoneyModel 类的第二个参数 n，表示创建 10 个 Agent
starter_model = MoneyModel(10)

#运行模型的 step 方法，激活所有 Agent
starter_model.step()
```

如果在创建对象时传入了 seed 参数，则每次运行模型时 Agent 的顺序会保持一致。

```{python}
#| display-language: true
starter_model = MoneyModel(10, seed = 1234)
starter_model.step()
```

### 模型修改练习

在原有模型的基础上，让 Agent 在激活时输出自己的 wealth。

```{python}
#| display-language: true
class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""

    def __init__(self, model):
        super().__init__(model)

        self.wealth = 1

    # 定义 say_wealth 方法，输出 Agent 的 wealth
    def say_wealth(self):
        print(f"Hi, I am an agent {self.unique_id},"
              f"and I have {self.wealth} dollars.")
        
class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n, seed=None):
        super().__init__(seed=seed)
        self.num_agents = n

        MoneyAgent.create_agents(model=self, n=n)

    def step(self):
        """Advance the model by one step."""
        
        self.agents.shuffle_do("say_wealth")
        
starter_model = MoneyModel(10)
starter_model.step()
```

## Agents 交换财富

```{python}
#| display-language: true
class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""

    def __init__(self, model):
        super().__init__(model)
        self.wealth = 1
        
    # 定义 exchange 方法，让 Agent 交换财富
    def exchange(self):
        if self.wealth > 0: #有钱才能转账
            #self.random, 是继承自 mesa.Agent 的随机数生成器
            #.choice(...) 在列表中随机选择一个 Agent
            #这里的self.model是在上一步—__init__中传入的模型对象
            other_agent = self.random.choice(self.model.agents)
            
            if other_agent is not None: #确保选到了一个 Agent
                other_agent.wealth += 1
                self.wealth -= 1


class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n, seed=None):
        super().__init__(seed = seed)
        self.num_agents = n

        MoneyAgent.create_agents(model=self, n=n)

    def step(self):
        """Advance the model by one step."""

        self.agents.shuffle_do("exchange")
```

### 运行模型

```{python}
#| display-language: true
model = MoneyModel(10, 1234)  # 创建 10 个 Agents

#这个 for 循环中 _ 是一个占位符
#表示我们不关心循环变量的值，也不关心现在运行了几次，只是想运行30次
for _ in range(30): 
    model.step()
```

### 可视化

```{python}
#| display-language: true
# 获取每个 Agent 的 wealth，放入一个列表
agent_wealth = [a.wealth for a in model.agents]
# 绘制直方图
g = sns.histplot(agent_wealth, discrete=True)
g.set(
    title="Wealth distribution", xlabel="Wealth", ylabel="number of agents"
);
plt.show()
```

#### 传入 R 中用 ggplot2 可视化

```{r}
#| display-language: true
library(tidyverse)

#所有的 python 对象都可以用 py$... 来访问
agent_wealth_r <- tibble(wealth = py$agent_wealth)

ggplot(agent_wealth_r, aes(x = wealth)) +
  geom_histogram(binwidth = 1, boundary = 0, closed = "left",
                 color = "black", fill="red") +
  labs(
    title = "Wealth distribution",
    x     = "Wealth",
    y     = "Number of agents"
  )+ theme_bw()
```

### 创建多个模型对象

为了更好地理解模型行为，可以创建多个模型对象，以观察整体分布。

```{python}
#| display-language: true
#创建一个空列表来存储循环结果，与 R 中类似，可以使循环运行更快
all_wealth = []
#运行 100 次模型，每个模型有 10 个 Agent，并运行 30 次 step
for _ in range(100):
    model = MoneyModel(10)
    for _ in range(30):
        model.step()
    #注意这里的缩进，说明下面这个循环是在for _ in range(100):循环中
    #这样每次运行一个模型就会存储所有 Agent 的 wealth
    for agent in model.agents:
        #注意这里使用了就地扩展 (append), 即直接向 all_wealth 列表添加元素
        #这是python的一个特性，直接在list后增加元素不是一个复杂的计算
        all_wealth.append(agent.wealth)
        
g = sns.histplot(all_wealth, discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");
plt.show()
```

#### 在 R 中查看模型运行结果

```{r}
#| display-language: true
all_wealth_r = tibble(wealth = py$all_wealth)
head(all_wealth_r)

ggplot(all_wealth_r, aes(x = wealth)) +
  geom_histogram(binwidth = 1, boundary = 0, closed = "left",
                 color = "black", fill="red") +
  labs(
    title = "Wealth distribution",
    x     = "Wealth",
    y     = "Number of agents"
  )+ theme_bw()
```

# 添加空间

## 导入依赖项

```{python}
#| display-language: true
import numpy as np
import pandas as pd
import seaborn as sns
import mesa
```

## 基础模型

以下模型即上述财富模型。

```{python}
#| display-language: true
class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""

    def __init__(self, model):
        super().__init__(model)
        self.wealth = 1

    def exchange(self):
        if self.wealth > 0:
            other_agent = self.random.choice(self.model.agents)
            if other_agent is not None:
                other_agent.wealth += 1
                self.wealth -= 1


class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n):
        super().__init__()
        self.num_agents = n
        MoneyAgent.create_agents(model=self, n=n)

    def step(self):
        """Advance the model by one step."""
        self.agents.shuffle_do("exchange")
```

```{python}
#| display-language: true
model = MoneyModel(10)
model.step()

print(f"You have {len(model.agents)} agents.")
```

## 添加空间

Mesa 提供两种空间类型：离散空间和连续空间。

-   离散空间：Agent 占据单元格或节点

-   连续空间：Agent 占据三维空间中的任何位置

以下使用经典笛卡尔坐标系下的离散空间，具有两个模块：单元格 (cell) 和单元格Agent。

单元格类表示一个具备以下功能的位置：

-   具有属性 (如温度、资源等)

-   追踪并限制其包含的 Agent

-   与相邻单元格连接

-   提供邻居 (neighborhood) 的信息

单元格 Agent 类：能够理解如何在单元格中存在和移动的 Agent。

-   CellAgent: 可以在单元格间移动的 Agent。

-   FixedAgent: 永久固定在单元格上的静止 Agent。

-   Grid2DMovingAgent: 具有特定网格移动能力的 Agent。

![Discrete Space](/images/Discrete_Space.webp)

-   网格 (Grid): 规则多边形

    -   摩尔邻域 (Moore Grid)：每个单元格的八个相邻单元格。

    -   冯诺依曼邻域 (Von Neumann Grid)：每个单元格的四个相邻单元格。

    -   六边形 (Hex Grid)：每个单元格的六个相邻单元格。

-   网络 (Network): 每个格点是图中的一个节点，连接关系由边（edge）定义，适合社交网络、通信拓扑等场景。

![Network](/images/images.png){width="500"}

-   Voronoi: 不规则多边形划分空间：给定一组中心点，每块多边形就是一个 Cell，适用于地理空间等不规则网格情形。

![Voronoi](/images/1_aYqqekIblklLxV7yKnBKaQ.png){width="500"}
